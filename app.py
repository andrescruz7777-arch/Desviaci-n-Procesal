# ============================================================
# ‚öñÔ∏è COS JudicIA ‚Äì Tablero Jur√≠dico Inteligente (v3.1 Cloud)
# Autor: Andr√©s Cruz / Contacto Solutions LegalTech
# ============================================================

import streamlit as st
import pandas as pd
import plotly.express as px
import io, calendar, unicodedata
from datetime import datetime

# ===============================
# üé® CONFIGURACI√ìN VISUAL
# ===============================
st.set_page_config(page_title="‚öñÔ∏è COS JudicIA ‚Äì Tablero Jur√≠dico Inteligente", layout="wide")

st.markdown("""
<style>
body, .stApp {background-color:#000!important;color:#FFF!important;}
h1,h2,h3,h4,h5,h6,p,div,label{color:#FFF!important;}
.alerta{font-size:18px;font-weight:600;padding:10px;border-radius:8px;
margin:10px 0;animation:pulse 2s infinite;}
@keyframes pulse{0%{opacity:1;}50%{opacity:.6;}100%{opacity:1;}}
.verde{color:#00FF00;}.amarillo{color:#FFFF00;}
.rojo{color:#FF0000;}.morado{color:#B388FF;}
table td,table th{color:#FFF!important;}
</style>
""", unsafe_allow_html=True)

st.title("‚öñÔ∏è COS JudicIA ‚Äì Tablero Jur√≠dico Inteligente")
st.markdown("Cargue el **Inventario mensual (.xlsx)** y la **Tabla de tiempos por etapa (.xlsx)** para generar el an√°lisis completo:")

# ===============================
# üìÇ CARGA DE ARCHIVOS
# ===============================
inventario_file = st.file_uploader("üìÇ Inventario mensual (.xlsx)", type=["xlsx"])
tiempos_file = st.file_uploader("‚è±Ô∏è Tabla tiempos etapas (.xlsx)", type=["xlsx"])

# ===============================
# üß© NORMALIZAR NOMBRES
# ===============================
def normalizar_col(col):
    col = str(col).upper().strip()
    col = ''.join(c for c in unicodedata.normalize('NFD', col) if unicodedata.category(c) != 'Mn')
    col = col.replace(" ", "_")
    return col

# ===============================
# üöÄ PROCESAMIENTO PRINCIPAL
# ===============================
if inventario_file and tiempos_file:

    # === DETECTAR FILA DE ENCABEZADO ===
    temp = pd.read_excel(inventario_file, header=None)
    header_row = None
    for i, row in temp.iterrows():
        fila = row.astype(str).str.upper()
        if any(fila.str.contains("DEUDOR|OPERACION|SUB|ETAPA|CAPITAL", na=False)):
            header_row = i
            break

    if header_row is None:
        st.error("‚ùå No se pudo detectar encabezado v√°lido en el inventario. Verifique el archivo.")
        st.stop()

    df = pd.read_excel(inventario_file, header=header_row)
    tiempos = pd.read_excel(tiempos_file)

    # === NORMALIZAR ENCABEZADOS ===
    df.columns = [normalizar_col(c) for c in df.columns]
    tiempos.columns = [normalizar_col(c) for c in tiempos.columns]

    st.write("üìò Columnas inventario detectadas:", list(df.columns))
    st.write("üìó Columnas tiempos detectadas:", list(tiempos.columns))

    # === MAPEO AUTOM√ÅTICO DE COLUMNAS ===
    def encontrar_columna(df, posibles):
        for col in df.columns:
            for p in posibles:
                if p in col:
                    return col
        return None

    mapa = {
        "DEUDOR": encontrar_columna(df, ["DEUDOR", "CEDULA", "IDENTIFICACION"]),
        "ETAPA_JURIDICA": encontrar_columna(df, ["ETAPA"]),
        "SUB-ETAPA_JURIDICA": encontrar_columna(df, ["SUB", "SUBETAPA"]),
        "CAPITAL_ACT": encontrar_columna(df, ["CAPITAL", "SALDO"]),
        "CIUDAD": encontrar_columna(df, ["CIUDAD", "REGIONAL"]),
        "JUZGADO": encontrar_columna(df, ["JUZGADO", "DESPACHO"]),
        "FECHA_ACT_INVENTARIO": encontrar_columna(df, ["FECHA_ACT_INVENTARIO", "FECHA_INVENTARIO"]),
        "FECHA_ACT_ETAPA": encontrar_columna(df, ["FECHA_ACT_ETAPA", "FECHA_ETAPA"]),
    }

    st.markdown("üîç **Columnas identificadas autom√°ticamente:**")
    st.json(mapa)

    # Renombrar columnas seg√∫n el mapeo
    for key, value in mapa.items():
        if value and key != value:
            df.rename(columns={value: key}, inplace=True)

    # === CRUCE CON TABLA DE TIEMPOS ===
    df = df.merge(
        tiempos[['DESCRIPCION_DE_LA_SUBETAPA', 'DURACION_MAXIMA_EN_DIAS']],
        how='left',
        left_on='SUB-ETAPA_JURIDICA',
        right_on='DESCRIPCION_DE_LA_SUBETAPA'
    )
    if 'DIAS_POR_ETAPA' not in df.columns:
        df['DIAS_POR_ETAPA'] = None
    df['DIAS_POR_ETAPA'] = df['DIAS_POR_ETAPA'].fillna(df['DURACION_MAXIMA_EN_DIAS'])
    df.drop(columns=['DESCRIPCION_DE_LA_SUBETAPA', 'DURACION_MAXIMA_EN_DIAS'], inplace=True, errors='ignore')

    # === CONVERSI√ìN DE FECHAS ===
    df['FECHA_ACT_INVENTARIO'] = pd.to_datetime(df['FECHA_ACT_INVENTARIO'], errors='coerce')
    df['FECHA_ACT_ETAPA'] = pd.to_datetime(df['FECHA_ACT_ETAPA'], errors='coerce')

    # === C√ÅLCULOS BASE ===
    df['VAR_FECHA_CALCULADA'] = (df['FECHA_ACT_INVENTARIO'] - df['FECHA_ACT_ETAPA']).dt.days.clip(lower=0)
    df['%_AVANCE'] = (df['VAR_FECHA_CALCULADA'] / df['DIAS_POR_ETAPA'] * 100).round(2)
    df['%_DESVIACION'] = ((df['VAR_FECHA_CALCULADA'] - df['DIAS_POR_ETAPA']) / df['DIAS_POR_ETAPA'] * 100).clip(lower=0).round(2)

    def clasificar_estado(row):
        if pd.isna(row['DIAS_POR_ETAPA']):
            return 'SIN_TIEMPO'
        if row['VAR_FECHA_CALCULADA'] > row['DIAS_POR_ETAPA']:
            return 'DESVIADO'
        return 'A_TIEMPO'
    df['ESTADO'] = df.apply(clasificar_estado, axis=1)

    # === POSIBLES DESV√çOS ===
    today = df['FECHA_ACT_INVENTARIO'].max()
    ultimo_dia = calendar.monthrange(today.year, today.month)[1]
    dias_fin_mes = ultimo_dia - today.day
    df['DIAS_RESTANTES'] = df['DIAS_POR_ETAPA'] - df['VAR_FECHA_CALCULADA']
    df['ALERTA_MES'] = df.apply(
        lambda x: 'POSIBLE_DESVIO_EN_EL_MES' if (x['DIAS_RESTANTES'] <= dias_fin_mes and x['DIAS_RESTANTES'] > 0) else '',
        axis=1
    )

    # ===============================
    # ‚ö†Ô∏è ALERTAS VISUALES
    # ===============================
    desviados = df[df['ESTADO'] == 'DESVIADO']
    posibles = df[df['ALERTA_MES'] != '']
    tiempo = df[df['ESTADO'] == 'A_TIEMPO']
    sin_dias = df[df['ESTADO'] == 'SIN_TIEMPO']

    if len(desviados): st.markdown(f"<div class='alerta rojo'>üö® {len(desviados)} procesos desviados.</div>", unsafe_allow_html=True)
    if len(posibles): st.markdown(f"<div class='alerta amarillo'>‚ö†Ô∏è {len(posibles)} procesos podr√≠an desviarse este mes.</div>", unsafe_allow_html=True)
    if len(tiempo): st.markdown(f"<div class='alerta verde'>‚úÖ {len(tiempo)} procesos dentro del plazo.</div>", unsafe_allow_html=True)
    if len(sin_dias): st.markdown(f"<div class='alerta morado'>üß© {len(sin_dias)} sin d√≠as definidos.</div>", unsafe_allow_html=True)

    # ===============================
    # üß© NORMALIZAR COLUMNAS ANTES DEL AGRUPAMIENTO
    # ===============================
    for col in ['ETAPA_JURIDICA', 'SUB-ETAPA_JURIDICA', 'DEUDOR']:
        if col not in df.columns:
            df[col] = "NO_REGISTRA"
        else:
            df[col] = df[col].astype(str).fillna("NO_REGISTRA")

    # ===============================
    # üìä RANKING SUBETAPAS / ETAPAS
    # ===============================
    df_ranking = df.groupby(['ETAPA_JURIDICA','SUB-ETAPA_JURIDICA','DEUDOR'], as_index=False).agg(
        DESVIADO=('ESTADO', lambda s: any(s == 'DESVIADO')),
        CAPITAL=('CAPITAL_ACT','sum')
    )

    resumen = df_ranking.groupby(['ETAPA_JURIDICA','SUB-ETAPA_JURIDICA'], as_index=False).agg(
        CLIENTES_TOTALES=('DEUDOR','nunique'),
        CLIENTES_DESVIADOS=('DESVIADO','sum'),
        CAPITAL_TOTAL=('CAPITAL','sum')
    )
    resumen['%_DESVIACION'] = (resumen['CLIENTES_DESVIADOS']/resumen['CLIENTES_TOTALES']*100).round(2)
    resumen['NIVEL'] = resumen['%_DESVIACION'].apply(lambda x:'üî¥ ALTA' if x>70 else('üü° MEDIA' if x>30 else 'üü¢ OK'))

    st.subheader("üìà Ranking por Subetapa Jur√≠dica")
    st.dataframe(resumen.sort_values('%_DESVIACION', ascending=False), use_container_width=True)

    fig = px.bar(resumen.sort_values('%_DESVIACION', ascending=False),
                 x='%_DESVIACION', y='SUB-ETAPA_JURIDICA',
                 color='NIVEL', text='CLIENTES_TOTALES',
                 color_discrete_map={'üî¥ ALTA':'red','üü° MEDIA':'yellow','üü¢ OK':'green'},
                 title='Ranking de Subetapas Jur√≠dicas')
    fig.update_layout(template='plotly_dark')
    st.plotly_chart(fig, use_container_width=True)

    # === RANKING ETAPAS ===
    ranking_etapas = resumen.groupby('ETAPA_JURIDICA', as_index=False).agg(
        CLIENTES_TOTALES=('CLIENTES_TOTALES','sum'),
        CLIENTES_DESVIADOS=('CLIENTES_DESVIADOS','sum'),
        CAPITAL_TOTAL=('CAPITAL_TOTAL','sum')
    )
    ranking_etapas['%_DESVIACION'] = (ranking_etapas['CLIENTES_DESVIADOS']/ranking_etapas['CLIENTES_TOTALES']*100).round(2)
    ranking_etapas['NIVEL'] = ranking_etapas['%_DESVIACION'].apply(lambda x:'üî¥ ALTA' if x>70 else('üü° MEDIA' if x>30 else 'üü¢ OK'))

    st.subheader("üìä Ranking por Etapa Jur√≠dica")
    st.dataframe(ranking_etapas.sort_values('%_DESVIACION', ascending=False), use_container_width=True)

    # === DETALLE CLIENTES ===
    columnas_existentes = [c for c in ['DEUDOR','ETAPA_JURIDICA','SUB-ETAPA_JURIDICA','ESTADO','CAPITAL_ACT','CIUDAD','JUZGADO','DIAS_POR_ETAPA','VAR_FECHA_CALCULADA','%_AVANCE','%_DESVIACION'] if c in df.columns]
    clientes_sub = df[columnas_existentes]
    st.subheader("üìô Detalle Clientes‚ÄìSubetapa")
    st.dataframe(clientes_sub, use_container_width=True)

    # === PR√ìXIMOS A VENCER ===
    st.subheader("üïí Pr√≥ximos a vencer en el mes")
    proximos = df[df['ALERTA_MES'] != '']
    st.dataframe(proximos[['DEUDOR','ETAPA_JURIDICA','SUB-ETAPA_JURIDICA','DIAS_RESTANTES','CAPITAL_ACT','CIUDAD','JUZGADO']], use_container_width=True)

    # === SEMAFORIZACI√ìN ===
    st.subheader("üö¶ Semaforizaci√≥n por Etapa y Subetapa")
    semaf = resumen.pivot(index='ETAPA_JURIDICA', columns='SUB-ETAPA_JURIDICA', values='%_DESVIACION')
    st.dataframe(semaf.style.background_gradient(cmap='RdYlGn_r'), use_container_width=True)

    # === EXPORTACI√ìN EXCEL ===
    st.subheader("üíæ Exportar resultados")
    output = io.BytesIO()
    with pd.ExcelWriter(output, engine='openpyxl') as writer:
        df.to_excel(writer, index=False, sheet_name='Base_Depurada')
        resumen.to_excel(writer, index=False, sheet_name='Ranking_Subetapas')
        ranking_etapas.to_excel(writer, index=False, sheet_name='Ranking_Etapas')
        clientes_sub.to_excel(writer, index=False, sheet_name='Clientes_Subetapa')
        proximos.to_excel(writer, index=False, sheet_name='Proximos_a_Vencer')
        semaf.to_excel(writer, sheet_name='Semaforizacion_Etapas')
    output.seek(0)
    st.download_button("‚¨áÔ∏è Exportar Inventario Depurado",
                       data=output,
                       file_name="Inventario_Depurado_Completo.xlsx",
                       mime="application/vnd.ms-excel")
else:
    st.info("üì§ Cargue los dos archivos para iniciar el an√°lisis.")
